{
  "collectionMethod": "batchscript",
  "datapoints": [
    {
      "max": "",
      "triggerInterval": 0,
      "dataType": 7,
      "maxDigits": 4,
      "description": "Alerts if the count of online canisters does not match the total count of canisters. \n0=ok\n1=total canisters do not match online canisters",
      "interpretMethod": "expression",
      "interpretExpr": "if(eq(OnlineCanisters,TotalCanisters),0,1)",
      "type": "gauge",
      "clearInterval": 0,
      "originId": "kWTohEElROaQDK6O3CkKEw",
      "min": "",
      "name": "CanisterAlert",
      "noData": "Do not trigger an alert"
    },
    {
      "max": "",
      "triggerInterval": 0,
      "dataType": 7,
      "maxDigits": 4,
      "description": "Alerts if the count of online fans do not match the total count of fans.\n\n0=ok\n1=total fans do not match online fans",
      "interpretMethod": "expression",
      "interpretExpr": "if(eq(OnlineFanModules,TotalFanModules),0,1)",
      "type": "gauge",
      "clearInterval": 0,
      "originId": "rxe5YpiSQVCrb7c293U3ng",
      "min": "",
      "name": "FanAlert",
      "noData": "Do not trigger an alert"
    },
    {
      "max": "",
      "triggerInterval": 0,
      "dataType": 7,
      "maxDigits": 4,
      "interpretMethod": "namevalue",
      "interpretExpr": "##WILDVALUE##.online_canisters",
      "type": "gauge",
      "clearInterval": 0,
      "originId": "yPMcFuq7Q7q7ILOhJMqyKw",
      "useValue": "output",
      "min": "",
      "name": "OnlineCanisters",
      "noData": "Do not trigger an alert"
    },
    {
      "max": "",
      "triggerInterval": 0,
      "dataType": 7,
      "maxDigits": 4,
      "interpretMethod": "namevalue",
      "interpretExpr": "##WILDVALUE##.online_fan_modules",
      "type": "gauge",
      "clearInterval": 0,
      "originId": "gtbtew-hTz6agnIcz5A1aQ",
      "useValue": "output",
      "min": "",
      "name": "OnlineFanModules",
      "noData": "Do not trigger an alert"
    },
    {
      "max": "",
      "triggerInterval": 0,
      "dataType": 7,
      "maxDigits": 4,
      "interpretMethod": "namevalue",
      "interpretExpr": "##WILDVALUE##.online_PSUs",
      "type": "gauge",
      "clearInterval": 0,
      "originId": "ISx8MRzFTbGTUCWdaetbHw",
      "useValue": "output",
      "min": "",
      "name": "OnlinePSUs",
      "noData": "Do not trigger an alert"
    },
    {
      "max": "",
      "triggerInterval": 0,
      "dataType": 7,
      "maxDigits": 4,
      "description": "Alerts if the count of online PSUs do not match the count of total PSUs.\n0=ok\n1=total online PSUs does not match total PSUs",
      "interpretMethod": "expression",
      "interpretExpr": "if(eq(OnlinePSUs,TotalPSUs),0,1)",
      "type": "gauge",
      "clearInterval": 0,
      "originId": "DlLXE0QiSc6GSDb_9qRaXg",
      "min": "",
      "name": "PSUAlert",
      "noData": "Do not trigger an alert"
    },
    {
      "max": "2",
      "triggerInterval": 0,
      "dataType": 7,
      "maxDigits": 4,
      "description": "0 = Online,\n1 = Offline,\n2 = Unknown",
      "interpretMethod": "namevalue",
      "interpretExpr": "##WILDVALUE##.status",
      "type": "gauge",
      "clearInterval": 0,
      "originId": "oVkYySfURp2WhlkVSNT0NA",
      "useValue": "output",
      "min": "0",
      "name": "Status",
      "noData": "Do not trigger an alert"
    },
    {
      "max": "",
      "triggerInterval": 0,
      "dataType": 7,
      "maxDigits": 4,
      "interpretMethod": "namevalue",
      "interpretExpr": "##WILDVALUE##.total_canisters",
      "type": "gauge",
      "clearInterval": 0,
      "originId": "IKH_RRM6TzaOiRY9tpC6cA",
      "useValue": "output",
      "min": "",
      "name": "TotalCanisters",
      "noData": "Do not trigger an alert"
    },
    {
      "max": "",
      "triggerInterval": 0,
      "dataType": 7,
      "maxDigits": 4,
      "interpretMethod": "namevalue",
      "interpretExpr": "##WILDVALUE##.total_fan_modules",
      "type": "gauge",
      "clearInterval": 0,
      "originId": "v3pT7KeVQLKqMKPB-HVngw",
      "useValue": "output",
      "min": "",
      "name": "TotalFanModules",
      "noData": "Do not trigger an alert"
    },
    {
      "max": "",
      "triggerInterval": 0,
      "dataType": 7,
      "maxDigits": 4,
      "interpretMethod": "namevalue",
      "interpretExpr": "##WILDVALUE##.total_PSUs",
      "type": "gauge",
      "clearInterval": 0,
      "originId": "-UYx64kdRgG0Kxzh7j6jww",
      "useValue": "output",
      "min": "",
      "name": "TotalPSUs",
      "noData": "Do not trigger an alert"
    }
  ],
  "searchKeywords": "",
  "displayedAs": "IBM Enclosures",
  "description": "",
  "appliesTo": "exists(\"ibm_api.user\") && exists(\"ibm_api.pass\")",
  "activeDiscovery": {
    "deleteInactiveInstances": false,
    "groupMethod": "none",
    "discoveryMethod": "ad_script",
    "autoDeleteInstances": false,
    "disableDiscoveredInstances": false,
    "filters": [],
    "params": {
      "type": "groovy",
      "content": "import org.apache.http.HttpEntity\r\nimport org.apache.http.HttpHeaders\r\nimport org.apache.http.HttpResponse\r\nimport org.apache.http.client.methods.HttpPost\r\nimport org.apache.http.conn.ssl.NoopHostnameVerifier\r\nimport org.apache.http.conn.ssl.SSLConnectionSocketFactory\r\nimport org.apache.http.impl.client.CloseableHttpClient\r\nimport org.apache.http.impl.client.HttpClients\r\nimport org.apache.http.util.EntityUtils\r\nimport groovy.json.JsonSlurper\r\nimport javax.net.ssl.SSLContext\r\nimport javax.net.ssl.TrustManager\r\nimport javax.net.ssl.X509TrustManager\r\nimport java.security.cert.X509Certificate\r\nimport com.santaba.agent.util.script.ScriptCache\r\n\r\n// Variables\r\ndef hostname = hostProps.get(\"system.hostname\")\r\ndef apiEndpoint = \"https://${hostname}:7443/rest/v1/lsenclosure\"\r\n\r\ndef cache = ScriptCache.getCache()\r\ndef key = \"IBMAuth.${hostname}.ClientSecret\"\r\ndef token = cache.get(key)\r\n\r\n// Create a custom SSL context that skips certificate validation\r\ndef trustAllCerts = [\r\n    new X509TrustManager() {\r\n        public void checkClientTrusted(X509Certificate[] x509Certificates, String s) {}\r\n        public void checkServerTrusted(X509Certificate[] x509Certificates, String s) {}\r\n        public X509Certificate[] getAcceptedIssuers() { null }\r\n    }\r\n] as TrustManager[]\r\n\r\ndef sslContext = SSLContext.getInstance(\"TLS\")\r\nsslContext.init(null, trustAllCerts, null)\r\n\r\n// Create a socket factory with a bypassed hostname verification\r\ndef socketFactory = new SSLConnectionSocketFactory(sslContext, NoopHostnameVerifier.INSTANCE)\r\n\r\n// Create an HTTP client with the custom SSL context and socket factory\r\ndef httpClient = HttpClients.custom().setSSLSocketFactory(socketFactory).build()\r\n\r\n// Create an HTTP POST request to retrieve the list of lsdrives\r\ndef httpPost = new HttpPost(apiEndpoint)\r\nhttpPost.setHeader(\"Content-Type\", \"application/json\")\r\nhttpPost.setHeader(\"X-Auth-Token\", \"${token}\")\r\n\r\ntry {\r\n    // Execute the request and retrieve the response\r\n    def response = httpClient.execute(httpPost)\r\n    \r\n    // Extract the response entity\r\n    def entity = response.getEntity()\r\n    \r\n    // Check if the request was successful (status code 200)\r\n    if (response.getStatusLine().getStatusCode() == 200) {\r\n        // Parse the response entity as JSON\r\n        def responseBody = EntityUtils.toString(entity)\r\n        def jsonSlurper = new JsonSlurper()\r\n        def lsenclosures = jsonSlurper.parseText(responseBody)\r\n        \r\n        // Loop through each lsenclosure and make a POST request for each id\r\n        lsenclosures.each { lsenclosure ->\r\n            def id = lsenclosure.id\r\n            def postEndpoint = \"${apiEndpoint}/${id}\"\r\n            def individualHttpPost = new HttpPost(postEndpoint)\r\n            individualHttpPost.setHeader(\"Content-Type\", \"application/json\")\r\n            individualHttpPost.setHeader(\"X-Auth-Token\", \"${token}\")\r\n            \r\n            try {\r\n                def postResponse = httpClient.execute(individualHttpPost)\r\n                def postEntity = postResponse.getEntity()\r\n                \r\n                if (postResponse.getStatusLine().getStatusCode() == 200) {\r\n                    def postResponseBody = EntityUtils.toString(postEntity)\r\n                    def postData = jsonSlurper.parseText(postResponseBody)\r\n                    \r\n                    def propertyMap = [:]\r\n                    postData.each { name, value ->\r\n                        propertyMap[\"${name}\"] = \"${value}\"\r\n                    }\r\n                    def joinedProperties = propertyMap.collect { propName, propValue -> \"auto.IBM.${propName}=${propValue}\" }.join(\"&\")\r\n                    println(\"${propertyMap.id}##Enclosure ${propertyMap.id}##${propertyMap.type}####${joinedProperties}\")\r\n                } else {\r\n                    println(\"Request for id ${id} failed with status code: ${postResponse.getStatusLine().getStatusCode()}\")\r\n                    println(\"Error message: ${EntityUtils.toString(postEntity)}\")\r\n                }\r\n            } finally {\r\n                // Ensure the post response entity is consumed\r\n                EntityUtils.consume(postEntity)\r\n            }\r\n        }\r\n    } else {\r\n        // Print the error message if the request was not successful\r\n        println(\"Request failed with status code: ${response.getStatusLine().getStatusCode()}\")\r\n        println(\"Error message: ${EntityUtils.toString(entity)}\")\r\n    }\r\n} finally {\r\n    // Close the HTTP client and release any system resources\r\n    httpClient.close()\r\n}\r\nreturn 0"
    },
    "discoveryInterval": "0m",
    "enabled": true,
    "showDeletedInstanceDays": 0
  },
  "collectionAttrs": {
    "type": "groovy",
    "content": "import org.apache.http.HttpEntity\r\nimport org.apache.http.HttpHeaders\r\nimport org.apache.http.HttpResponse\r\nimport org.apache.http.client.methods.HttpPost\r\nimport org.apache.http.conn.ssl.NoopHostnameVerifier\r\nimport org.apache.http.conn.ssl.SSLConnectionSocketFactory\r\nimport org.apache.http.impl.client.CloseableHttpClient\r\nimport org.apache.http.impl.client.HttpClients\r\nimport org.apache.http.util.EntityUtils\r\nimport groovy.json.JsonSlurper\r\nimport javax.net.ssl.SSLContext\r\nimport javax.net.ssl.TrustManager\r\nimport javax.net.ssl.X509TrustManager\r\nimport java.security.cert.X509Certificate\r\nimport com.santaba.agent.util.script.ScriptCache\r\n\r\n// Variables\r\ndef hostname = hostProps.get(\"system.hostname\")\r\ndef apiEndpoint = \"https://${hostname}:7443/rest/v1/lsenclosure\"\r\n\r\ndef cache = ScriptCache.getCache()\r\ndef key = \"IBMAuth.${hostname}.ClientSecret\"\r\ndef token = cache.get(key)\r\n\r\n// Create a custom SSL context that skips certificate validation\r\ndef trustAllCerts = [\r\n    new X509TrustManager() {\r\n        public void checkClientTrusted(X509Certificate[] x509Certificates, String s) {}\r\n        public void checkServerTrusted(X509Certificate[] x509Certificates, String s) {}\r\n        public X509Certificate[] getAcceptedIssuers() { null }\r\n    }\r\n] as TrustManager[]\r\n\r\ndef sslContext = SSLContext.getInstance(\"TLS\")\r\nsslContext.init(null, trustAllCerts, null)\r\n\r\n// Create a socket factory with a bypassed hostname verification\r\ndef socketFactory = new SSLConnectionSocketFactory(sslContext, NoopHostnameVerifier.INSTANCE)\r\n\r\n// Create an HTTP client with the custom SSL context and socket factory\r\ndef httpClient = HttpClients.custom().setSSLSocketFactory(socketFactory).build()\r\n\r\n\r\n// Create an HTTP GET request to retrieve system status\r\ndef httpPost = new HttpPost(apiEndpoint)\r\n\r\n// Set Headers\r\nhttpPost.setHeader(\"Content-Type\", \"application/json\")\r\nhttpPost.setHeader(\"X-Auth-Token\", \"${token}\")\r\n\r\n    \r\ntry {\r\n    // Execute the request and retrieve the response\r\n    def response = httpClient.execute(httpPost)\r\n    \r\n    // Extract the response entity\r\n    def entity = response.getEntity()\r\n    \r\n    // Check if the request was successful (status code 200)\r\n    if (response.getStatusLine().getStatusCode() == 200) {\r\n        // Parse the response entity as JSON\r\n        def responseBody = EntityUtils.toString(entity)\r\n        def jsonSlurper = new JsonSlurper()\r\n        def data = jsonSlurper.parseText(responseBody)\r\n          \r\n        data.each { member ->\r\n            member.each { name, value ->\r\n                if (name == \"status\") {\r\n                    switch (value) {\r\n                        case \"online\":\r\n                            println(\"${member.id}.${name}=0\")\r\n                            break\r\n                        case \"offline\":\r\n                            println(\"${member.id}.${name}=1\")\r\n                            break\r\n                        default:\r\n                            println(\"${member.id}.${name}=2\")\r\n                    }\r\n                } else {\r\n                    println(\"${member.id}.${name}=${value}\")\r\n                }\r\n            }\r\n        }\r\n        \r\n    } else {\r\n        // Print the error message if the request was not successful\r\n        println(\"Request failed with status code: ${response.getStatusLine().getStatusCode()}\")\r\n        println(\"Error message: ${EntityUtils.toString(entity)}\")\r\n    }\r\n} finally {\r\n    // Close the HTTP client and release any system resources\r\n    httpClient.close()\r\n}\r\nreturn 0"
  },
  "type": 0,
  "technicalNotes": "",
  "useWildValueAsUniqueIdentifier": false,
  "version": 1718138863,
  "registryMetadata": {
    "currentUuid": "krOsbGvcRfS5cks5BzSsIw",
    "originalUuid": "krOsbGvcRfS5cks5BzSsIw",
    "locatorId": "",
    "authorCompanyUuid": "043d42a3-246c-436f-8500-de1e9f7979e8",
    "registryVersion": "1.0.0",
    "checksum": "bb09b88f8a6534707a3ac6e51c1aa03a",
    "namespace": "",
    "registryId": ""
  },
  "multiInstance": true,
  "name": "IBM_LSENCLOSURE",
  "collectionInterval": "5m",
  "dataSourceType": 1,
  "group": "",
  "headers": {
    "cache-control": "no-cache, no-store",
    "content-disposition": "attachment; filename=\"IBM_LSENCLOSURE.json\"",
    "content-encoding": "gzip",
    "content-type": "application/json",
    "date": "Wed, 25 Sep 2024 13:00:53 GMT",
    "server": "LM",
    "strict-transport-security": "max-age=31536000; includeSubDomains",
    "vary": "accept-encoding",
    "x-content-type-options": "nosniff",
    "x-server-version": "210-8"
  }
}